let scene, camera, renderer, currentMesh;
function initThreeJS() {
  const e = document.getElementById("threeCanvas"),
    t = e.parentElement;
  (scene = new THREE.Scene()),
    (scene.background = new THREE.Color(15790320)),
    (camera = new THREE.PerspectiveCamera(
      75,
      t.clientWidth / t.clientHeight,
      0.1,
      1e3
    )),
    camera.position.set(5, 5, 5),
    (renderer = new THREE.WebGLRenderer({
      canvas: e,
      antialias: !0,
      powerPreference: "default",
      precision: "mediump",
    })),
    renderer.setSize(t.clientWidth, t.clientHeight),
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)),
    (renderer.shadowMap.enabled = !0),
    (renderer.shadowMap.type = THREE.PCFSoftShadowMap);
  const n = new THREE.AmbientLight(4210752, 0.6);
  scene.add(n);
  const r = new THREE.DirectionalLight(16777215, 0.8);
  r.position.set(10, 10, 5),
    (r.castShadow = !0),
    (r.shadow.mapSize.width = 1024),
    (r.shadow.mapSize.height = 1024),
    scene.add(r),
    setupOrbitControls(),
    window.addEventListener("resize", onWindowResize),
    animate();
}
function setupOrbitControls() {
  let e = !1,
    t = 0,
    n = 0,
    r = 0,
    o = 0,
    i = 0,
    a = 0;
  const s = document.getElementById("threeCanvas");
  s.addEventListener("mousedown", (n) => {
    (e = !0), (t = n.clientX), (n = n.clientY), n.preventDefault();
  }),
    s.addEventListener("mousemove", (i) => {
      if (!e) return;
      const a = i.clientX - t,
        s = i.clientY - n;
      (r += 0.01 * a),
        (o += 0.01 * s),
        (t = i.clientX),
        (n = i.clientY),
        i.preventDefault();
    }),
    s.addEventListener("mouseup", (t) => {
      (e = !1), t.preventDefault();
    }),
    s.addEventListener(
      "touchstart",
      (t) => {
        1 === t.touches.length &&
          ((e = !0),
          (t = t.touches[0].clientX),
          (n = t.touches[0].clientY),
          console.log("Touch started:", t, n)),
          t.preventDefault();
      },
      { passive: !1 }
    ),
    s.addEventListener(
      "touchmove",
      (i) => {
        if (!e || 1 !== i.touches.length) return;
        const a = i.touches[0].clientX - t,
          s = i.touches[0].clientY - n;
        (r += 0.01 * a),
          (o += 0.01 * s),
          (t = i.touches[0].clientX),
          (n = i.touches[0].clientY),
          i.preventDefault();
      },
      { passive: !1 }
    ),
    s.addEventListener(
      "touchend",
      (t) => {
        (e = !1), console.log("Touch ended"), t.preventDefault();
      },
      { passive: !1 }
    ),
    s.addEventListener(
      "wheel",
      (e) => {
        const t = e.deltaY > 0 ? 1.1 : 0.9;
        camera.position.multiplyScalar(t);
        const n = camera.position.length();
        n < 2 && camera.position.normalize().multiplyScalar(2),
          n > 15 && camera.position.normalize().multiplyScalar(15),
          e.preventDefault();
      },
      { passive: !1 }
    );
  let c = 0;
  s.addEventListener("touchstart", (e) => {
    if (2 === e.touches.length) {
      const t = e.touches[0],
        n = e.touches[1];
      c = Math.sqrt(
        Math.pow(n.clientX - t.clientX, 2) + Math.pow(n.clientY - t.clientY, 2)
      );
    }
  }),
    s.addEventListener("touchmove", (e) => {
      if (2 === e.touches.length) {
        const t = e.touches[0],
          n = e.touches[1],
          r = Math.sqrt(
            Math.pow(n.clientX - t.clientX, 2) +
              Math.pow(n.clientY - t.clientY, 2)
          );
        if (c > 0) {
          const e = c / r;
          camera.position.multiplyScalar(e);
          const t = camera.position.length();
          t < 2 && camera.position.normalize().multiplyScalar(2),
            t > 15 && camera.position.normalize().multiplyScalar(15);
        }
        (c = r), e.preventDefault();
      }
    }),
    (function e() {
      (i += 0.1 * (r - i)),
        (a += 0.1 * (o - a)),
        currentMesh &&
          (currentMesh.userData && currentMesh.userData.initialXRotation
            ? currentMesh.userData.initialXRotation
            : 0,
          currentMesh.userData && currentMesh.userData.initialYRotation
            ? currentMesh.userData.initialYRotation
            : 0,
          currentMesh.userData && currentMesh.userData.initialZRotation
            ? currentMesh.userData.initialZRotation
            : 0,
          currentMesh.rotation.set(
            currentMesh.userData && currentMesh.userData.initialXRotation
              ? currentMesh.userData.initialXRotation
              : 0,
            currentMesh.userData && currentMesh.userData.initialYRotation
              ? currentMesh.userData.initialYRotation
              : 0,
            currentMesh.userData && currentMesh.userData.initialZRotation
              ? currentMesh.userData.initialZRotation
              : 0
          ),
          currentMesh.rotateX(i),
          currentMesh.rotateY(a),
          currentMesh.userData &&
            currentMesh.userData.needsInitialRotation &&
            currentMesh.rotateZ(Math.PI / 2)),
        requestAnimationFrame(e);
    })();
}
function onWindowResize() {
  const e = document.querySelector(".shape-container");
  e &&
    camera &&
    renderer &&
    ((camera.aspect = e.clientWidth / e.clientHeight),
    camera.updateProjectionMatrix(),
    renderer.setSize(e.clientWidth, e.clientHeight),
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)));
}
function animate() {
  requestAnimationFrame(animate), renderer.render(scene, camera);
}
function create3DShape(e, t, n) {
  if (!scene) return;
  currentMesh &&
    (scene.remove(currentMesh),
    currentMesh.geometry.dispose(),
    currentMesh.material.dispose());
  const r = new THREE.Color(t),
    o = new THREE.MeshPhongMaterial({
      color: r,
      shininess: 100,
      specular: new THREE.Color(2236962),
    });
  let i;
  const a = 1.5,
    s = 10,
    c = 0.3;
  switch (e) {
    case "Round":
      (i = new THREE.CylinderGeometry(a, a, s, 32)),
        (currentMesh = new THREE.Mesh(i, o)),
        (currentMesh.userData.needsInitialRotation = !0),
        (currentMesh.userData.initialXRotation = 0),
        (currentMesh.userData.initialYRotation = 0),
        (currentMesh.userData.initialZRotation = 0);
      break;
    case "Square":
      (i = new THREE.BoxGeometry(2 * a, 2 * a, s)),
        (currentMesh = new THREE.Mesh(i, o)),
        (currentMesh.userData.initialXRotation = 0),
        (currentMesh.userData.initialYRotation = 0),
        (currentMesh.userData.initialZRotation = 0);
      break;
    case "Rectangle":
    case "Rectangle/Plate":
    case "Rectangle/Plate/Sheet":
      (i = new THREE.BoxGeometry(2.5 * a, a, s)),
        (currentMesh = new THREE.Mesh(i, o)),
        (currentMesh.userData.initialXRotation = 0),
        (currentMesh.userData.initialYRotation = 0),
        (currentMesh.userData.initialZRotation = 0);
      break;
    case "Hexagonal":
      const h = a,
        l = s,
        u = new THREE.Shape();
      for (let e = 0; e < 6; e++) {
        const t = (e / 6) * Math.PI * 2,
          n = Math.cos(t) * h,
          r = Math.sin(t) * h;
        0 === e ? u.moveTo(n, r) : u.lineTo(n, r);
      }
      u.closePath(),
        (i = new THREE.ExtrudeGeometry(u, {
          depth: l,
          bevelEnabled: !1,
          curveSegments: 200,
        })),
        i.translate(0, 0, -l / 2),
        i.rotateX(-Math.PI / 2),
        (currentMesh = new THREE.Mesh(i, o)),
        (currentMesh.userData.needsInitialRotation = !0),
        (currentMesh.userData.initialXRotation = 0),
        (currentMesh.userData.initialYRotation = 0),
        (currentMesh.userData.initialZRotation = 0);
      break;
    case "Octagonal":
      const d = a,
        g = s,
        p = new THREE.Shape();
      for (let e = 0; e < 8; e++) {
        const t = (e / 8) * Math.PI * 2,
          n = Math.cos(t) * d,
          r = Math.sin(t) * d;
        0 === e ? p.moveTo(n, r) : p.lineTo(n, r);
      }
      p.closePath(),
        (i = new THREE.ExtrudeGeometry(p, {
          depth: g,
          bevelEnabled: !1,
          curveSegments: 200,
        })),
        i.translate(0, 0, -g / 2),
        i.rotateX(-Math.PI / 2),
        (currentMesh = new THREE.Mesh(i, o)),
        (currentMesh.userData.needsInitialRotation = !0),
        (currentMesh.userData.initialXRotation = 0),
        (currentMesh.userData.initialYRotation = 0),
        (currentMesh.userData.initialZRotation = 0);
      break;
    case "Plate":
    case "Sheet":
      (i = new THREE.BoxGeometry(s, c, 2.5 * a)),
        (currentMesh = new THREE.Mesh(i, o)),
        (currentMesh.userData.initialXRotation = 0),
        (currentMesh.userData.initialYRotation = 0),
        (currentMesh.userData.initialZRotation = 0);
      break;
    case "Pipe":
      const m = a,
        f = 0.6 * a,
        x = s,
        y = new THREE.Shape();
      y.absarc(0, 0, m, 0, 2 * Math.PI, !1);
      const v = new THREE.Path();
      v.absarc(0, 0, f, 0, 2 * Math.PI, !0),
        y.holes.push(v),
        (i = new THREE.ExtrudeGeometry(y, {
          depth: x,
          bevelEnabled: !1,
          curveSegments: 200,
        })),
        i.translate(0, 0, -x / 2),
        i.rotateX(-Math.PI / 2),
        (currentMesh = new THREE.Mesh(i, o)),
        (currentMesh.userData.needsInitialRotation = !0),
        (currentMesh.userData.initialXRotation = 0),
        (currentMesh.userData.initialYRotation = 0),
        (currentMesh.userData.initialZRotation = 0);
      break;
    case "Ring":
      const M = new THREE.Shape();
      M.absarc(0, 0, a, 0, 2 * Math.PI, !1);
      const T = new THREE.Path();
      T.absarc(0, 0, 0.6 * a, 0, 2 * Math.PI, !0),
        M.holes.push(T),
        (i = new THREE.ExtrudeGeometry(M, {
          depth: 2 * c,
          bevelEnabled: !1,
          curveSegments: 200,
        })),
        (currentMesh = new THREE.Mesh(i, o)),
        (currentMesh.userData.initialXRotation = -Math.PI / 2),
        (currentMesh.userData.initialYRotation = 0),
        (currentMesh.userData.initialZRotation = 0),
        (currentMesh.rotation.x = -Math.PI / 2);
      break;
    case "Hexagonal (Round)":
      const w = a,
        b = 0.6 * a,
        E = s,
        R = new THREE.Shape();
      for (let e = 0; e < 6; e++) {
        const t = (e / 6) * Math.PI * 2,
          n = Math.cos(t) * w,
          r = Math.sin(t) * w;
        0 === e ? R.moveTo(n, r) : R.lineTo(n, r);
      }
      R.closePath();
      const C = new THREE.Path();
      C.absarc(0, 0, b, 0, 2 * Math.PI, !0),
        R.holes.push(C),
        (i = new THREE.ExtrudeGeometry(R, {
          depth: E,
          bevelEnabled: !1,
          curveSegments: 200,
        })),
        i.translate(0, 0, -E / 2),
        i.rotateX(-Math.PI / 2),
        (currentMesh = new THREE.Mesh(i, o)),
        (currentMesh.userData.needsInitialRotation = !0),
        (currentMesh.userData.initialXRotation = 0),
        (currentMesh.userData.initialYRotation = 0),
        (currentMesh.userData.initialZRotation = 0);
      break;
    case "Sphere":
      (i = new THREE.SphereGeometry(a, 32, 16)),
        (currentMesh = new THREE.Mesh(i, o)),
        (currentMesh.userData.initialXRotation = 0),
        (currentMesh.userData.initialYRotation = 0),
        (currentMesh.userData.initialZRotation = 0);
      break;
    case "Square (Round)":
      const S = 2 * a,
        P = 0.6 * a,
        A = s,
        X = new THREE.Shape(),
        G = S / 2;
      X.moveTo(-G, -G),
        X.lineTo(G, -G),
        X.lineTo(G, G),
        X.lineTo(-G, G),
        X.closePath();
      const I = new THREE.Path();
      I.absarc(0, 0, P, 0, 2 * Math.PI, !0),
        X.holes.push(I),
        (i = new THREE.ExtrudeGeometry(X, {
          depth: A,
          bevelEnabled: !1,
          curveSegments: 200,
        })),
        i.translate(0, 0, -A / 2),
        i.rotateX(-Math.PI / 2),
        (currentMesh = new THREE.Mesh(i, o)),
        (currentMesh.userData.needsInitialRotation = !0),
        (currentMesh.userData.initialXRotation = 0),
        (currentMesh.userData.initialYRotation = 0),
        (currentMesh.userData.initialZRotation = 0);
      break;
    case "Square Pipe":
      const B = 2 * a,
        O = 1.2 * a,
        k = s,
        z = new THREE.Shape(),
        D = B / 2,
        F = O / 2;
      z.moveTo(-D, -D),
        z.lineTo(D, -D),
        z.lineTo(D, D),
        z.lineTo(-D, D),
        z.closePath();
      const L = new THREE.Path();
      L.moveTo(-F, -F),
        L.lineTo(F, -F),
        L.lineTo(F, F),
        L.lineTo(-F, F),
        L.closePath(),
        z.holes.push(L),
        (i = new THREE.ExtrudeGeometry(z, {
          depth: k,
          bevelEnabled: !1,
          curveSegments: 200,
        })),
        i.translate(0, 0, -k / 2),
        i.rotateX(-Math.PI / 2),
        (currentMesh = new THREE.Mesh(i, o)),
        (currentMesh.userData.needsInitialRotation = !0),
        (currentMesh.userData.initialXRotation = 0),
        (currentMesh.userData.initialYRotation = 0),
        (currentMesh.userData.initialZRotation = 0);
      break;
    case "Rectangle Pipe":
      const N = 2.5 * a,
        j = a,
        U = c,
        H = s,
        V = N - 2 * U,
        q = j - 2 * U,
        W = new THREE.Shape(),
        Y = N / 2,
        K = j / 2,
        Q = V / 2,
        Z = q / 2;
      W.moveTo(-Y, -K),
        W.lineTo(Y, -K),
        W.lineTo(Y, K),
        W.lineTo(-Y, K),
        W.closePath();
      const J = new THREE.Path();
      J.moveTo(-Q, -Z),
        J.lineTo(Q, -Z),
        J.lineTo(Q, Z),
        J.lineTo(-Q, Z),
        J.closePath(),
        W.holes.push(J),
        (i = new THREE.ExtrudeGeometry(W, {
          depth: H,
          bevelEnabled: !1,
          curveSegments: 200,
        })),
        i.translate(0, 0, -H / 2),
        i.rotateX(-Math.PI / 2),
        (currentMesh = new THREE.Mesh(i, o)),
        (currentMesh.userData.needsInitialRotation = !0),
        (currentMesh.userData.initialXRotation = 0),
        (currentMesh.userData.initialYRotation = 0),
        (currentMesh.userData.initialZRotation = 0);
      break;
    case "Triangle":
      const $ = 2 * a,
        _ = (Math.sqrt(3) / 2) * $,
        ee = s,
        te = new THREE.Shape(),
        ne = $ / 2;
      te.moveTo(-ne, 0),
        te.lineTo(ne, 0),
        te.lineTo(0, _),
        te.closePath(),
        (i = new THREE.ExtrudeGeometry(te, {
          depth: ee,
          bevelEnabled: !1,
          curveSegments: 200,
        })),
        i.translate(0, 0, -ee / 2),
        i.rotateX(-Math.PI / 2),
        (currentMesh = new THREE.Mesh(i, o)),
        (currentMesh.userData.needsInitialRotation = !0),
        (currentMesh.userData.initialXRotation = 0),
        (currentMesh.userData.initialYRotation = 0),
        (currentMesh.userData.initialZRotation = 0);
      break;
    case "Trapezoid":
    case "Trapezium":
    case "Trapezoid/Trapezium":
      const re = 2.5 * a,
        oe = a,
        ie = a,
        ae = s,
        se = new THREE.Shape(),
        ce = re / 2,
        he = oe / 2;
      se.moveTo(-ce, 0),
        se.lineTo(ce, 0),
        se.lineTo(he, ie),
        se.lineTo(-he, ie),
        se.closePath(),
        (i = new THREE.ExtrudeGeometry(se, {
          depth: ae,
          bevelEnabled: !1,
          curveSegments: 200,
        })),
        i.translate(0, 0, -ae / 2),
        i.rotateX(-Math.PI / 2),
        (currentMesh = new THREE.Mesh(i, o)),
        (currentMesh.userData.needsInitialRotation = !0),
        (currentMesh.userData.initialXRotation = 0),
        (currentMesh.userData.initialYRotation = 0),
        (currentMesh.userData.initialZRotation = 0);
      break;
    case "Oval":
      const le = 2.5 * a,
        ue = a,
        de = s,
        ge = new THREE.Shape(),
        pe = le / 2,
        me = ue / 2;
      ge.ellipse(0, 0, pe, me, 0, 2 * Math.PI, !1, 0),
        (i = new THREE.ExtrudeGeometry(ge, {
          depth: de,
          bevelEnabled: !1,
          curveSegments: 200,
        })),
        i.translate(0, 0, -de / 2),
        i.rotateX(-Math.PI / 2),
        (currentMesh = new THREE.Mesh(i, o)),
        (currentMesh.userData.needsInitialRotation = !0),
        (currentMesh.userData.initialXRotation = 0),
        (currentMesh.userData.initialYRotation = 0),
        (currentMesh.userData.initialZRotation = 0);
      break;
    case "CR Square":
      const fe = 2 * a,
        xe = 0.2 * a,
        ye = s,
        ve = new THREE.Shape(),
        Me = fe / 2,
        Te = xe;
      ve.moveTo(-Me + Te, -Me),
        ve.lineTo(Me - Te, -Me),
        ve.quadraticCurveTo(Me, -Me, Me, -Me + Te),
        ve.lineTo(Me, Me - Te),
        ve.quadraticCurveTo(Me, Me, Me - Te, Me),
        ve.lineTo(-Me + Te, Me),
        ve.quadraticCurveTo(-Me, Me, -Me, Me - Te),
        ve.lineTo(-Me, -Me + Te),
        ve.quadraticCurveTo(-Me, -Me, -Me + Te, -Me),
        (i = new THREE.ExtrudeGeometry(ve, {
          depth: ye,
          bevelEnabled: !1,
          curveSegments: 200,
        })),
        i.translate(0, 0, -ye / 2),
        i.rotateX(-Math.PI / 2),
        (currentMesh = new THREE.Mesh(i, o)),
        (currentMesh.userData.needsInitialRotation = !0),
        (currentMesh.userData.initialXRotation = 0),
        (currentMesh.userData.initialYRotation = 0),
        (currentMesh.userData.initialZRotation = 0);
      break;
    case "CR Rectangle":
      const we = 2.5 * a,
        be = a,
        Ee = 0.2 * a,
        Re = s,
        Ce = new THREE.Shape(),
        Se = we / 2,
        Pe = be / 2,
        Ae = Ee;
      Ce.moveTo(-Se + Ae, -Pe),
        Ce.lineTo(Se - Ae, -Pe),
        Ce.quadraticCurveTo(Se, -Pe, Se, -Pe + Ae),
        Ce.lineTo(Se, Pe - Ae),
        Ce.quadraticCurveTo(Se, Pe, Se - Ae, Pe),
        Ce.lineTo(-Se + Ae, Pe),
        Ce.quadraticCurveTo(-Se, Pe, -Se, Pe - Ae),
        Ce.lineTo(-Se, -Pe + Ae),
        Ce.quadraticCurveTo(-Se, -Pe, -Se + Ae, -Pe),
        (i = new THREE.ExtrudeGeometry(Ce, {
          depth: Re,
          bevelEnabled: !1,
          curveSegments: 200,
        })),
        i.translate(0, 0, -Re / 2),
        i.rotateX(-Math.PI / 2),
        (currentMesh = new THREE.Mesh(i, o)),
        (currentMesh.userData.needsInitialRotation = !0),
        (currentMesh.userData.initialXRotation = 0),
        (currentMesh.userData.initialYRotation = 0),
        (currentMesh.userData.initialZRotation = 0);
      break;
    case "Angle":
      const Xe = 2 * a,
        Ge = 1.67 * a,
        Ie = c,
        Be = 0.83 * c,
        Oe = s,
        ke = new THREE.Shape();
      ke.moveTo(0, 0),
        ke.lineTo(Xe, 0),
        ke.lineTo(Xe, Ie),
        ke.lineTo(Be, Ie),
        ke.lineTo(Be, Ge),
        ke.lineTo(0, Ge),
        ke.lineTo(0, 0),
        (i = new THREE.ExtrudeGeometry(ke, {
          depth: Oe,
          bevelEnabled: !1,
          curveSegments: 200,
        })),
        i.translate(-Xe / 2, -Ge / 2, -Oe / 2),
        i.rotateX(-Math.PI / 2),
        (currentMesh = new THREE.Mesh(i, o)),
        (currentMesh.userData.needsInitialRotation = !0),
        (currentMesh.userData.initialXRotation = 0),
        (currentMesh.userData.initialYRotation = 0),
        (currentMesh.userData.initialZRotation = 0);
      break;
    case "Channel":
      const ze = 2 * a,
        De = 2.67 * a,
        Fe = c,
        Le = 0.83 * c,
        Ne = s,
        je = new THREE.Shape();
      je.moveTo(0, 0),
        je.lineTo(ze, 0),
        je.lineTo(ze, Fe),
        je.lineTo(Le, Fe),
        je.lineTo(Le, De - Fe),
        je.lineTo(ze, De - Fe),
        je.lineTo(ze, De),
        je.lineTo(0, De),
        je.lineTo(0, 0),
        (i = new THREE.ExtrudeGeometry(je, {
          depth: Ne,
          bevelEnabled: !1,
          curveSegments: 200,
        })),
        i.translate(-ze / 2, -De / 2, -Ne / 2),
        i.rotateX(-Math.PI / 2),
        (currentMesh = new THREE.Mesh(i, o)),
        (currentMesh.userData.needsInitialRotation = !0),
        (currentMesh.userData.initialXRotation = 0),
        (currentMesh.userData.initialYRotation = 0),
        (currentMesh.userData.initialZRotation = 0);
      break;
    case "T Bar":
      const Ue = 2.33 * a,
        He = 2 * a,
        Ve = c,
        qe = 0.83 * c,
        We = s,
        Ye = new THREE.Shape(),
        Ke = (Ue - qe) / 2;
      Ye.moveTo(Ke, 0),
        Ye.lineTo(Ke + qe, 0),
        Ye.lineTo(Ke + qe, He - Ve),
        Ye.lineTo(Ue, He - Ve),
        Ye.lineTo(Ue, He),
        Ye.lineTo(0, He),
        Ye.lineTo(0, He - Ve),
        Ye.lineTo(Ke, He - Ve),
        Ye.lineTo(Ke, 0),
        (i = new THREE.ExtrudeGeometry(Ye, {
          depth: We,
          bevelEnabled: !1,
          curveSegments: 200,
        })),
        i.translate(-Ue / 2, -He / 2, -We / 2),
        i.rotateX(-Math.PI / 2),
        (currentMesh = new THREE.Mesh(i, o)),
        (currentMesh.userData.needsInitialRotation = !0),
        (currentMesh.userData.initialXRotation = 0),
        (currentMesh.userData.initialYRotation = 0),
        (currentMesh.userData.initialZRotation = 0);
      break;
    case "I Beam":
      const Qe = 2 * a,
        Ze = 2.67 * a,
        Je = c,
        $e = 0.67 * c,
        _e = s,
        et = new THREE.Shape(),
        tt = (Qe - $e) / 2;
      et.moveTo(0, 0),
        et.lineTo(Qe, 0),
        et.lineTo(Qe, Je),
        et.lineTo(tt + $e, Je),
        et.lineTo(tt + $e, Ze - Je),
        et.lineTo(Qe, Ze - Je),
        et.lineTo(Qe, Ze),
        et.lineTo(0, Ze),
        et.lineTo(0, Ze - Je),
        et.lineTo(tt, Ze - Je),
        et.lineTo(tt, Je),
        et.lineTo(0, Je),
        et.lineTo(0, 0),
        (i = new THREE.ExtrudeGeometry(et, {
          depth: _e,
          bevelEnabled: !1,
          curveSegments: 200,
        })),
        i.translate(-Qe / 2, -Ze / 2, -_e / 2),
        i.rotateX(-Math.PI / 2),
        (currentMesh = new THREE.Mesh(i, o)),
        (currentMesh.userData.needsInitialRotation = !0),
        (currentMesh.userData.initialXRotation = 0),
        (currentMesh.userData.initialYRotation = 0),
        (currentMesh.userData.initialZRotation = 0);
      break;
    case "C Shape":
      const nt = 2 * a,
        rt = 1.33 * a,
        ot = 0.67 * c,
        it = 0.27 * a,
        at = s,
        st = new THREE.Shape();
      st.moveTo(0, 0),
        st.lineTo(nt, 0),
        st.lineTo(nt, rt),
        st.lineTo(nt - it, rt),
        st.lineTo(nt - it, rt - ot),
        st.lineTo(nt - ot, rt - ot),
        st.lineTo(nt - ot, ot),
        st.lineTo(ot, ot),
        st.lineTo(ot, rt - ot),
        st.lineTo(it, rt - ot),
        st.lineTo(it, rt),
        st.lineTo(0, rt),
        st.lineTo(0, 0),
        (i = new THREE.ExtrudeGeometry(st, {
          depth: at,
          bevelEnabled: !1,
          curveSegments: 200,
        })),
        i.translate(-nt / 2, -rt / 2, -at / 2),
        i.rotateX(-Math.PI / 2),
        (currentMesh = new THREE.Mesh(i, o)),
        (currentMesh.userData.needsInitialRotation = !0),
        (currentMesh.userData.initialXRotation = 0),
        (currentMesh.userData.initialYRotation = 0),
        (currentMesh.userData.initialZRotation = 0);
      break;
    case "E Shape":
      const ct = 2 * a,
        ht = 2.67 * a,
        lt = c,
        ut = 0.83 * c,
        dt = s,
        gt = new THREE.Shape(),
        pt = (ht - lt) / 2;
      gt.moveTo(0, 0),
        gt.lineTo(ct, 0),
        gt.lineTo(ct, lt),
        gt.lineTo(ut, lt),
        gt.lineTo(ut, pt),
        gt.lineTo(ct, pt),
        gt.lineTo(ct, pt + lt),
        gt.lineTo(ut, pt + lt),
        gt.lineTo(ut, ht - lt),
        gt.lineTo(ct, ht - lt),
        gt.lineTo(ct, ht),
        gt.lineTo(0, ht),
        gt.lineTo(0, 0),
        (i = new THREE.ExtrudeGeometry(gt, {
          depth: dt,
          bevelEnabled: !1,
          curveSegments: 200,
        })),
        i.translate(-ct / 2, -ht / 2, -dt / 2),
        i.rotateX(-Math.PI / 2),
        (currentMesh = new THREE.Mesh(i, o)),
        (currentMesh.userData.needsInitialRotation = !0),
        (currentMesh.userData.initialXRotation = 0),
        (currentMesh.userData.initialYRotation = 0),
        (currentMesh.userData.initialZRotation = 0);
      break;
    default:
      (i = new THREE.BoxGeometry(1, 1, 1)),
        (currentMesh = new THREE.Mesh(i, o)),
        (currentMesh.userData.initialXRotation = 0),
        (currentMesh.userData.initialYRotation = 0),
        (currentMesh.userData.initialZRotation = 0);
  }
  currentMesh &&
    ((currentMesh.castShadow = !0),
    (currentMesh.receiveShadow = !0),
    scene.add(currentMesh),
    camera.position.set(5, 5, 5),
    camera.lookAt(0, 0, 0));
}
function clearThreeJSVisualization() {
  currentMesh &&
    scene &&
    (scene.remove(currentMesh),
    currentMesh.geometry.dispose(),
    currentMesh.material.dispose(),
    (currentMesh = null));
}
